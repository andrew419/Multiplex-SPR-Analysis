# Complete Kinetic Workflow
# Andrew Crowley
# June, 2017

# PACKAGES

library(tidyverse)
library(stringr)
library(readxl)

# PREP

# by habit, Scrubber results take the form of an Excel workbook,
#   one receptor per sheet

sheets <- excel_sheets("file_name") # USER INPUT HERE

for(i in 1:length(sheets)) {
  assign(as.character(sheets[i]), read_excel("file_name", i)) # USER INPUT HERE
}

# bypass process to insert analyte column for the moment, manually write in
R2A_R131$analyte <- "R2A_R131"
R2A_H131$analyte <- "R2A_H131"
R2B$analyte <- "R2B"
R3A_F158$analyte <- "R3A_F158"
R3A_V158$analyte <- "R3A_V158"
R3B_NA1$analyte <- "R3B_NA1"
R3B_SH$analyte <- "R3B_SH"

full <- do.call(rbind, mget(sheets))
full <- rename(full, spot_name = X__1, Res_StDev = Res.sd)
full$spot_name <- tolower(full$spot_name)
full$Rmax <- as.numeric(full$Rmax)

# historically, the protein concentrations used to print spots generate
#   very similar results; by extracting the spot concentration, results
#   can be grouped by higher-order feature
#   (eg. subclass or Fc point mutation for antibodies)

name_split <- strsplit(dataframe$variable, "_") # USER INPUT HERE

full$conc <- NA

for (i in 1:length(name_split)) {
  full$conc[i] <- name_split[[i]][length(name_split[[i]])]
}

full$conc[str_detect(full$spot_name, "blank") == T] <- 0
full$conc[str_detect(full$spot_name, "bsa") == T] <- 0

full$group_1 <- NA

for (i in 1:length(name_split)) {
  full$group_1[i] <- name_split[[i]][1]
}
# revisit with a method for splitting 2nd and 3rd terms

# kinetic analysis in Scrubber outputs KD values using molarity units
#   taking the form "_M"; unable to properly compare without anchoring
#   to a uniform baseline of 10^0 (ie. 1 M)

full$KD_value <- substr(full$KD, 1, nchar(full$KD) - 2)
full$KD_value <- as.numeric(full$KD_value)

full$KD_unit <- substr(full$KD, nchar(full$KD) - 1, nchar(full$KD))
full$KD_unit <- tolower(full$KD_unit)
# if blanks / (-) ctrls have rare molar scale values, will this break?

# units <- c("mm", "um", "nm", "pm")
# scaling <- c(1e-03, 1e-06, 1e-09, 1e-012)
# scale_to_molar <- data.frame(units, scaling)

# this is a temporary workaround that should be replaced with a process
#   that uses something more like the scale_to_molar arrangement above:

full$affinity <- NA
full$scale_factor <- 1

full$scale_factor[full$KD_unit == "mm"] <- 1e-03
full$scale_factor[full$KD_unit == "um"] <- 1e-06
full$scale_factor[full$KD_unit == "nm"] <- 1e-09
full$scale_factor[full$KD_unit == "pm"] <- 1e-012

full$affinity <- full$scale_factor * full$KD_value

# at present, work does not utilize ka and kd values,
#   only equilibrium dissociation constant (KD)

full <- select(full, spot_name, group_1, conc, analyte, Rmax, Res_StDev, affinity)

# FILTER

# per the recommendation of the US distributor for the SPR, the hallmarks of
#   genuine receptor-ligand interactions are:
#     Rmax value > 50 response units (RU)
#     residual stdev < 10-15

full$sig_strength <- "acceptable"
full$sig_strength[full$Rmax > 50] <- "normal"
full$sig_strength[full$Rmax < 30] <- "poor"
full$sig_strength[is.na(full$Rmax)] <- "poor"
# would a constant percentage (eg. 10%) of Rmax converted to serve as
#   residual stdev threshold be better?
#   large Rmax and residual stdev seem to be correlated

full$curve_fit <- "acceptable"
full$curve_fit[full$Res_StDev < 10] <- "normal"
full$curve_fit[full$Res_StDev > 15] <- "poor"
full$curve_fit[is.na(full$Res_StDev)] <- "poor"

full$valid <- 0
full$valid[full$sig_strength == "normal" & full$curve_fit == "normal"] <- 1
full$valid[full$sig_strength == "acceptable" & full$curve_fit == "normal"] <- 1
full$valid[full$sig_strength == "normal" & full$curve_fit == "acceptable"] <- 1
full$valid[is.na(full$affinity)] <- 0

full <- select(full, spot_name, group_1, conc, analyte, affinity, valid)

# VISUALIZATION
