# Clean and Prep (Steady State Results)
# Andrew Crowley
# May - June, 2017

# packages

library(tidyverse)
library(readxl)

# by habit, Scrubber results take the form of an Excel worksheet,
#   one receptor per sheet

# bypass readxl looping for the moment and manually read in CSVs

# bypass list / function to insert analyte column, manually write in

full <- rbind(df1, df2, ...) # USER INPUT HERE
full <- rename(full, spot_name = Name, Rmax_global = Rmax, KD_global = KD, Rmax_local = Rmax.1, KD_local = KD.1)
full <- select(full, spot_name, receptor, Rmax_global, KD_global, Rmax_local, KD_local)

# local results are already exported as properly scaled, numeric-only values,
#   but global results need to be scaled to molar baseline

full$KD_global_value <- substr(full$KD_global, 1, nchar(full$KD_global) - 2)
full$KD_global_value <- as.numeric(full$KD_global_value)

full$KD_global_unit <- substr(full$KD_global, nchar(full$KD_global) - 1, nchar(full$KD_global))
full$KD_global_unit <- tolower(full$KD_global_unit)
# if blanks / (-) ctrls have rare molar scale values, will this break?

units <- c("mm", "um", "nm", "pm")
scaling <- c(1e-03, 1e-06, 1e-09, 1e-012)
scale_to_molar <- data.frame(units, scaling)

# bypass pipes for the moment and use temporary variables

# by convention, the names of the spots on the chip include the concentration
#   of the solution used to print them; different concentrations have been
#   demonstrated to produce similar results so the spots should be split for
#   grouping by protein ID

# global vs local variable names would not be compatible with a single
#   visualization module unless split and renamed

global_SS <- select(full, spot_name, receptor, Rmax_global, affinity_global)
global_SS <- rename(global_SS, Rmax = Rmax_global, affinity = affinity_global)

local_SS <- select(full, spot_name, receptor, Rmax_local, KD_local)
local_SS <- rename(local_SS, Rmax = Rmax_local, affinity = KD_local)
